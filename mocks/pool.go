// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/tarantool/go-tarantool/v2"
	"github.com/tarantool/go-tarantool/v2/pool"
	"sync"
	"time"
)

// Ensure, that PoolerMock does implement Pooler.
// If this is not the case, regenerate this file with moq.
var _ Pooler = &PoolerMock{}

// PoolerMock is a mock implementation of Pooler.
//
//	func TestSomethingThatUsesPooler(t *testing.T) {
//
//		// make and configure a mocked Pooler
//		mockedPooler := &PoolerMock{
//			CallFunc: func(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
//				panic("mock out the Call method")
//			},
//			Call16Func: func(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
//				panic("mock out the Call16 method")
//			},
//			Call16AsyncFunc: func(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
//				panic("mock out the Call16Async method")
//			},
//			Call16TypedFunc: func(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
//				panic("mock out the Call16Typed method")
//			},
//			Call17Func: func(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
//				panic("mock out the Call17 method")
//			},
//			Call17AsyncFunc: func(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
//				panic("mock out the Call17Async method")
//			},
//			Call17TypedFunc: func(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
//				panic("mock out the Call17Typed method")
//			},
//			CallAsyncFunc: func(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
//				panic("mock out the CallAsync method")
//			},
//			CallTypedFunc: func(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
//				panic("mock out the CallTyped method")
//			},
//			CloseFunc: func() []error {
//				panic("mock out the Close method")
//			},
//			ConfiguredTimeoutFunc: func(mode pool.Mode) (time.Duration, error) {
//				panic("mock out the ConfiguredTimeout method")
//			},
//			ConnectedNowFunc: func(mode pool.Mode) (bool, error) {
//				panic("mock out the ConnectedNow method")
//			},
//			DeleteFunc: func(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) ([]interface{}, error) {
//				panic("mock out the Delete method")
//			},
//			DeleteAsyncFunc: func(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) *tarantool.Future {
//				panic("mock out the DeleteAsync method")
//			},
//			DeleteTypedFunc: func(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error {
//				panic("mock out the DeleteTyped method")
//			},
//			DoFunc: func(req tarantool.Request, mode pool.Mode) *tarantool.Future {
//				panic("mock out the Do method")
//			},
//			EvalFunc: func(expr string, args interface{}, mode pool.Mode) ([]interface{}, error) {
//				panic("mock out the Eval method")
//			},
//			EvalAsyncFunc: func(expr string, args interface{}, mode pool.Mode) *tarantool.Future {
//				panic("mock out the EvalAsync method")
//			},
//			EvalTypedFunc: func(expr string, args interface{}, result interface{}, mode pool.Mode) error {
//				panic("mock out the EvalTyped method")
//			},
//			ExecuteFunc: func(expr string, args interface{}, mode pool.Mode) ([]interface{}, error) {
//				panic("mock out the Execute method")
//			},
//			ExecuteAsyncFunc: func(expr string, args interface{}, mode pool.Mode) *tarantool.Future {
//				panic("mock out the ExecuteAsync method")
//			},
//			ExecuteTypedFunc: func(expr string, args interface{}, result interface{}, mode pool.Mode) (tarantool.SQLInfo, []tarantool.ColumnMetaData, error) {
//				panic("mock out the ExecuteTyped method")
//			},
//			GetTypedFunc: func(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error {
//				panic("mock out the GetTyped method")
//			},
//			InsertFunc: func(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error) {
//				panic("mock out the Insert method")
//			},
//			InsertAsyncFunc: func(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future {
//				panic("mock out the InsertAsync method")
//			},
//			InsertTypedFunc: func(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error {
//				panic("mock out the InsertTyped method")
//			},
//			NewPreparedFunc: func(expr string, mode pool.Mode) (*tarantool.Prepared, error) {
//				panic("mock out the NewPrepared method")
//			},
//			NewStreamFunc: func(mode pool.Mode) (*tarantool.Stream, error) {
//				panic("mock out the NewStream method")
//			},
//			NewWatcherFunc: func(key string, callback tarantool.WatchCallback, mode pool.Mode) (tarantool.Watcher, error) {
//				panic("mock out the NewWatcher method")
//			},
//			PingFunc: func(mode pool.Mode) ([]interface{}, error) {
//				panic("mock out the Ping method")
//			},
//			ReplaceFunc: func(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error) {
//				panic("mock out the Replace method")
//			},
//			ReplaceAsyncFunc: func(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future {
//				panic("mock out the ReplaceAsync method")
//			},
//			ReplaceTypedFunc: func(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error {
//				panic("mock out the ReplaceTyped method")
//			},
//			SelectFunc: func(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) ([]interface{}, error) {
//				panic("mock out the Select method")
//			},
//			SelectAsyncFunc: func(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) *tarantool.Future {
//				panic("mock out the SelectAsync method")
//			},
//			SelectTypedFunc: func(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, result interface{}, mode ...pool.Mode) error {
//				panic("mock out the SelectTyped method")
//			},
//			UpdateFunc: func(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error) {
//				panic("mock out the Update method")
//			},
//			UpdateAsyncFunc: func(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future {
//				panic("mock out the UpdateAsync method")
//			},
//			UpdateTypedFunc: func(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, result interface{}, mode ...pool.Mode) error {
//				panic("mock out the UpdateTyped method")
//			},
//			UpsertFunc: func(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error) {
//				panic("mock out the Upsert method")
//			},
//			UpsertAsyncFunc: func(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future {
//				panic("mock out the UpsertAsync method")
//			},
//		}
//
//		// use mockedPooler in code that requires Pooler
//		// and then make assertions.
//
//	}
type PoolerMock struct {
	// CallFunc mocks the Call method.
	CallFunc func(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error)

	// Call16Func mocks the Call16 method.
	Call16Func func(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error)

	// Call16AsyncFunc mocks the Call16Async method.
	Call16AsyncFunc func(functionName string, args interface{}, mode pool.Mode) *tarantool.Future

	// Call16TypedFunc mocks the Call16Typed method.
	Call16TypedFunc func(functionName string, args interface{}, result interface{}, mode pool.Mode) error

	// Call17Func mocks the Call17 method.
	Call17Func func(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error)

	// Call17AsyncFunc mocks the Call17Async method.
	Call17AsyncFunc func(functionName string, args interface{}, mode pool.Mode) *tarantool.Future

	// Call17TypedFunc mocks the Call17Typed method.
	Call17TypedFunc func(functionName string, args interface{}, result interface{}, mode pool.Mode) error

	// CallAsyncFunc mocks the CallAsync method.
	CallAsyncFunc func(functionName string, args interface{}, mode pool.Mode) *tarantool.Future

	// CallTypedFunc mocks the CallTyped method.
	CallTypedFunc func(functionName string, args interface{}, result interface{}, mode pool.Mode) error

	// CloseFunc mocks the Close method.
	CloseFunc func() []error

	// ConfiguredTimeoutFunc mocks the ConfiguredTimeout method.
	ConfiguredTimeoutFunc func(mode pool.Mode) (time.Duration, error)

	// ConnectedNowFunc mocks the ConnectedNow method.
	ConnectedNowFunc func(mode pool.Mode) (bool, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) ([]interface{}, error)

	// DeleteAsyncFunc mocks the DeleteAsync method.
	DeleteAsyncFunc func(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) *tarantool.Future

	// DeleteTypedFunc mocks the DeleteTyped method.
	DeleteTypedFunc func(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error

	// DoFunc mocks the Do method.
	DoFunc func(req tarantool.Request, mode pool.Mode) *tarantool.Future

	// EvalFunc mocks the Eval method.
	EvalFunc func(expr string, args interface{}, mode pool.Mode) ([]interface{}, error)

	// EvalAsyncFunc mocks the EvalAsync method.
	EvalAsyncFunc func(expr string, args interface{}, mode pool.Mode) *tarantool.Future

	// EvalTypedFunc mocks the EvalTyped method.
	EvalTypedFunc func(expr string, args interface{}, result interface{}, mode pool.Mode) error

	// ExecuteFunc mocks the Execute method.
	ExecuteFunc func(expr string, args interface{}, mode pool.Mode) ([]interface{}, error)

	// ExecuteAsyncFunc mocks the ExecuteAsync method.
	ExecuteAsyncFunc func(expr string, args interface{}, mode pool.Mode) *tarantool.Future

	// ExecuteTypedFunc mocks the ExecuteTyped method.
	ExecuteTypedFunc func(expr string, args interface{}, result interface{}, mode pool.Mode) (tarantool.SQLInfo, []tarantool.ColumnMetaData, error)

	// GetTypedFunc mocks the GetTyped method.
	GetTypedFunc func(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error

	// InsertFunc mocks the Insert method.
	InsertFunc func(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error)

	// InsertAsyncFunc mocks the InsertAsync method.
	InsertAsyncFunc func(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future

	// InsertTypedFunc mocks the InsertTyped method.
	InsertTypedFunc func(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error

	// NewPreparedFunc mocks the NewPrepared method.
	NewPreparedFunc func(expr string, mode pool.Mode) (*tarantool.Prepared, error)

	// NewStreamFunc mocks the NewStream method.
	NewStreamFunc func(mode pool.Mode) (*tarantool.Stream, error)

	// NewWatcherFunc mocks the NewWatcher method.
	NewWatcherFunc func(key string, callback tarantool.WatchCallback, mode pool.Mode) (tarantool.Watcher, error)

	// PingFunc mocks the Ping method.
	PingFunc func(mode pool.Mode) ([]interface{}, error)

	// ReplaceFunc mocks the Replace method.
	ReplaceFunc func(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error)

	// ReplaceAsyncFunc mocks the ReplaceAsync method.
	ReplaceAsyncFunc func(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future

	// ReplaceTypedFunc mocks the ReplaceTyped method.
	ReplaceTypedFunc func(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error

	// SelectFunc mocks the Select method.
	SelectFunc func(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) ([]interface{}, error)

	// SelectAsyncFunc mocks the SelectAsync method.
	SelectAsyncFunc func(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) *tarantool.Future

	// SelectTypedFunc mocks the SelectTyped method.
	SelectTypedFunc func(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, result interface{}, mode ...pool.Mode) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error)

	// UpdateAsyncFunc mocks the UpdateAsync method.
	UpdateAsyncFunc func(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future

	// UpdateTypedFunc mocks the UpdateTyped method.
	UpdateTypedFunc func(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, result interface{}, mode ...pool.Mode) error

	// UpsertFunc mocks the Upsert method.
	UpsertFunc func(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error)

	// UpsertAsyncFunc mocks the UpsertAsync method.
	UpsertAsyncFunc func(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future

	// calls tracks calls to the methods.
	calls struct {
		// Call holds details about calls to the Call method.
		Call []struct {
			// FunctionName is the functionName argument value.
			FunctionName string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Call16 holds details about calls to the Call16 method.
		Call16 []struct {
			// FunctionName is the functionName argument value.
			FunctionName string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Call16Async holds details about calls to the Call16Async method.
		Call16Async []struct {
			// FunctionName is the functionName argument value.
			FunctionName string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Call16Typed holds details about calls to the Call16Typed method.
		Call16Typed []struct {
			// FunctionName is the functionName argument value.
			FunctionName string
			// Args is the args argument value.
			Args interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Call17 holds details about calls to the Call17 method.
		Call17 []struct {
			// FunctionName is the functionName argument value.
			FunctionName string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Call17Async holds details about calls to the Call17Async method.
		Call17Async []struct {
			// FunctionName is the functionName argument value.
			FunctionName string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Call17Typed holds details about calls to the Call17Typed method.
		Call17Typed []struct {
			// FunctionName is the functionName argument value.
			FunctionName string
			// Args is the args argument value.
			Args interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// CallAsync holds details about calls to the CallAsync method.
		CallAsync []struct {
			// FunctionName is the functionName argument value.
			FunctionName string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// CallTyped holds details about calls to the CallTyped method.
		CallTyped []struct {
			// FunctionName is the functionName argument value.
			FunctionName string
			// Args is the args argument value.
			Args interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// ConfiguredTimeout holds details about calls to the ConfiguredTimeout method.
		ConfiguredTimeout []struct {
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// ConnectedNow holds details about calls to the ConnectedNow method.
		ConnectedNow []struct {
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Key is the key argument value.
			Key interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// DeleteAsync holds details about calls to the DeleteAsync method.
		DeleteAsync []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Key is the key argument value.
			Key interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// DeleteTyped holds details about calls to the DeleteTyped method.
		DeleteTyped []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Key is the key argument value.
			Key interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// Do holds details about calls to the Do method.
		Do []struct {
			// Req is the req argument value.
			Req tarantool.Request
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Eval holds details about calls to the Eval method.
		Eval []struct {
			// Expr is the expr argument value.
			Expr string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// EvalAsync holds details about calls to the EvalAsync method.
		EvalAsync []struct {
			// Expr is the expr argument value.
			Expr string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// EvalTyped holds details about calls to the EvalTyped method.
		EvalTyped []struct {
			// Expr is the expr argument value.
			Expr string
			// Args is the args argument value.
			Args interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Execute holds details about calls to the Execute method.
		Execute []struct {
			// Expr is the expr argument value.
			Expr string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// ExecuteAsync holds details about calls to the ExecuteAsync method.
		ExecuteAsync []struct {
			// Expr is the expr argument value.
			Expr string
			// Args is the args argument value.
			Args interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// ExecuteTyped holds details about calls to the ExecuteTyped method.
		ExecuteTyped []struct {
			// Expr is the expr argument value.
			Expr string
			// Args is the args argument value.
			Args interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// GetTyped holds details about calls to the GetTyped method.
		GetTyped []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Key is the key argument value.
			Key interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// Insert holds details about calls to the Insert method.
		Insert []struct {
			// Space is the space argument value.
			Space interface{}
			// Tuple is the tuple argument value.
			Tuple interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// InsertAsync holds details about calls to the InsertAsync method.
		InsertAsync []struct {
			// Space is the space argument value.
			Space interface{}
			// Tuple is the tuple argument value.
			Tuple interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// InsertTyped holds details about calls to the InsertTyped method.
		InsertTyped []struct {
			// Space is the space argument value.
			Space interface{}
			// Tuple is the tuple argument value.
			Tuple interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// NewPrepared holds details about calls to the NewPrepared method.
		NewPrepared []struct {
			// Expr is the expr argument value.
			Expr string
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// NewStream holds details about calls to the NewStream method.
		NewStream []struct {
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// NewWatcher holds details about calls to the NewWatcher method.
		NewWatcher []struct {
			// Key is the key argument value.
			Key string
			// Callback is the callback argument value.
			Callback tarantool.WatchCallback
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Mode is the mode argument value.
			Mode pool.Mode
		}
		// Replace holds details about calls to the Replace method.
		Replace []struct {
			// Space is the space argument value.
			Space interface{}
			// Tuple is the tuple argument value.
			Tuple interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// ReplaceAsync holds details about calls to the ReplaceAsync method.
		ReplaceAsync []struct {
			// Space is the space argument value.
			Space interface{}
			// Tuple is the tuple argument value.
			Tuple interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// ReplaceTyped holds details about calls to the ReplaceTyped method.
		ReplaceTyped []struct {
			// Space is the space argument value.
			Space interface{}
			// Tuple is the tuple argument value.
			Tuple interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// Select holds details about calls to the Select method.
		Select []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Offset is the offset argument value.
			Offset uint32
			// Limit is the limit argument value.
			Limit uint32
			// Iterator is the iterator argument value.
			Iterator tarantool.Iter
			// Key is the key argument value.
			Key interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// SelectAsync holds details about calls to the SelectAsync method.
		SelectAsync []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Offset is the offset argument value.
			Offset uint32
			// Limit is the limit argument value.
			Limit uint32
			// Iterator is the iterator argument value.
			Iterator tarantool.Iter
			// Key is the key argument value.
			Key interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// SelectTyped holds details about calls to the SelectTyped method.
		SelectTyped []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Offset is the offset argument value.
			Offset uint32
			// Limit is the limit argument value.
			Limit uint32
			// Iterator is the iterator argument value.
			Iterator tarantool.Iter
			// Key is the key argument value.
			Key interface{}
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Key is the key argument value.
			Key interface{}
			// Ops is the ops argument value.
			Ops *tarantool.Operations
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// UpdateAsync holds details about calls to the UpdateAsync method.
		UpdateAsync []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Key is the key argument value.
			Key interface{}
			// Ops is the ops argument value.
			Ops *tarantool.Operations
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// UpdateTyped holds details about calls to the UpdateTyped method.
		UpdateTyped []struct {
			// Space is the space argument value.
			Space interface{}
			// Index is the index argument value.
			Index interface{}
			// Key is the key argument value.
			Key interface{}
			// Ops is the ops argument value.
			Ops *tarantool.Operations
			// Result is the result argument value.
			Result interface{}
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// Upsert holds details about calls to the Upsert method.
		Upsert []struct {
			// Space is the space argument value.
			Space interface{}
			// Tuple is the tuple argument value.
			Tuple interface{}
			// Ops is the ops argument value.
			Ops *tarantool.Operations
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
		// UpsertAsync holds details about calls to the UpsertAsync method.
		UpsertAsync []struct {
			// Space is the space argument value.
			Space interface{}
			// Tuple is the tuple argument value.
			Tuple interface{}
			// Ops is the ops argument value.
			Ops *tarantool.Operations
			// Mode is the mode argument value.
			Mode []pool.Mode
		}
	}
	lockCall              sync.RWMutex
	lockCall16            sync.RWMutex
	lockCall16Async       sync.RWMutex
	lockCall16Typed       sync.RWMutex
	lockCall17            sync.RWMutex
	lockCall17Async       sync.RWMutex
	lockCall17Typed       sync.RWMutex
	lockCallAsync         sync.RWMutex
	lockCallTyped         sync.RWMutex
	lockClose             sync.RWMutex
	lockConfiguredTimeout sync.RWMutex
	lockConnectedNow      sync.RWMutex
	lockDelete            sync.RWMutex
	lockDeleteAsync       sync.RWMutex
	lockDeleteTyped       sync.RWMutex
	lockDo                sync.RWMutex
	lockEval              sync.RWMutex
	lockEvalAsync         sync.RWMutex
	lockEvalTyped         sync.RWMutex
	lockExecute           sync.RWMutex
	lockExecuteAsync      sync.RWMutex
	lockExecuteTyped      sync.RWMutex
	lockGetTyped          sync.RWMutex
	lockInsert            sync.RWMutex
	lockInsertAsync       sync.RWMutex
	lockInsertTyped       sync.RWMutex
	lockNewPrepared       sync.RWMutex
	lockNewStream         sync.RWMutex
	lockNewWatcher        sync.RWMutex
	lockPing              sync.RWMutex
	lockReplace           sync.RWMutex
	lockReplaceAsync      sync.RWMutex
	lockReplaceTyped      sync.RWMutex
	lockSelect            sync.RWMutex
	lockSelectAsync       sync.RWMutex
	lockSelectTyped       sync.RWMutex
	lockUpdate            sync.RWMutex
	lockUpdateAsync       sync.RWMutex
	lockUpdateTyped       sync.RWMutex
	lockUpsert            sync.RWMutex
	lockUpsertAsync       sync.RWMutex
}

// Call calls CallFunc.
func (mock *PoolerMock) Call(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	if mock.CallFunc == nil {
		panic("PoolerMock.CallFunc: method is nil but Pooler.Call was just called")
	}
	callInfo := struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}{
		FunctionName: functionName,
		Args:         args,
		Mode:         mode,
	}
	mock.lockCall.Lock()
	mock.calls.Call = append(mock.calls.Call, callInfo)
	mock.lockCall.Unlock()
	return mock.CallFunc(functionName, args, mode)
}

// CallCalls gets all the calls that were made to Call.
// Check the length with:
//
//	len(mockedPooler.CallCalls())
func (mock *PoolerMock) CallCalls() []struct {
	FunctionName string
	Args         interface{}
	Mode         pool.Mode
} {
	var calls []struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}
	mock.lockCall.RLock()
	calls = mock.calls.Call
	mock.lockCall.RUnlock()
	return calls
}

// Call16 calls Call16Func.
func (mock *PoolerMock) Call16(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	if mock.Call16Func == nil {
		panic("PoolerMock.Call16Func: method is nil but Pooler.Call16 was just called")
	}
	callInfo := struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}{
		FunctionName: functionName,
		Args:         args,
		Mode:         mode,
	}
	mock.lockCall16.Lock()
	mock.calls.Call16 = append(mock.calls.Call16, callInfo)
	mock.lockCall16.Unlock()
	return mock.Call16Func(functionName, args, mode)
}

// Call16Calls gets all the calls that were made to Call16.
// Check the length with:
//
//	len(mockedPooler.Call16Calls())
func (mock *PoolerMock) Call16Calls() []struct {
	FunctionName string
	Args         interface{}
	Mode         pool.Mode
} {
	var calls []struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}
	mock.lockCall16.RLock()
	calls = mock.calls.Call16
	mock.lockCall16.RUnlock()
	return calls
}

// Call16Async calls Call16AsyncFunc.
func (mock *PoolerMock) Call16Async(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
	if mock.Call16AsyncFunc == nil {
		panic("PoolerMock.Call16AsyncFunc: method is nil but Pooler.Call16Async was just called")
	}
	callInfo := struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}{
		FunctionName: functionName,
		Args:         args,
		Mode:         mode,
	}
	mock.lockCall16Async.Lock()
	mock.calls.Call16Async = append(mock.calls.Call16Async, callInfo)
	mock.lockCall16Async.Unlock()
	return mock.Call16AsyncFunc(functionName, args, mode)
}

// Call16AsyncCalls gets all the calls that were made to Call16Async.
// Check the length with:
//
//	len(mockedPooler.Call16AsyncCalls())
func (mock *PoolerMock) Call16AsyncCalls() []struct {
	FunctionName string
	Args         interface{}
	Mode         pool.Mode
} {
	var calls []struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}
	mock.lockCall16Async.RLock()
	calls = mock.calls.Call16Async
	mock.lockCall16Async.RUnlock()
	return calls
}

// Call16Typed calls Call16TypedFunc.
func (mock *PoolerMock) Call16Typed(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
	if mock.Call16TypedFunc == nil {
		panic("PoolerMock.Call16TypedFunc: method is nil but Pooler.Call16Typed was just called")
	}
	callInfo := struct {
		FunctionName string
		Args         interface{}
		Result       interface{}
		Mode         pool.Mode
	}{
		FunctionName: functionName,
		Args:         args,
		Result:       result,
		Mode:         mode,
	}
	mock.lockCall16Typed.Lock()
	mock.calls.Call16Typed = append(mock.calls.Call16Typed, callInfo)
	mock.lockCall16Typed.Unlock()
	return mock.Call16TypedFunc(functionName, args, result, mode)
}

// Call16TypedCalls gets all the calls that were made to Call16Typed.
// Check the length with:
//
//	len(mockedPooler.Call16TypedCalls())
func (mock *PoolerMock) Call16TypedCalls() []struct {
	FunctionName string
	Args         interface{}
	Result       interface{}
	Mode         pool.Mode
} {
	var calls []struct {
		FunctionName string
		Args         interface{}
		Result       interface{}
		Mode         pool.Mode
	}
	mock.lockCall16Typed.RLock()
	calls = mock.calls.Call16Typed
	mock.lockCall16Typed.RUnlock()
	return calls
}

// Call17 calls Call17Func.
func (mock *PoolerMock) Call17(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	if mock.Call17Func == nil {
		panic("PoolerMock.Call17Func: method is nil but Pooler.Call17 was just called")
	}
	callInfo := struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}{
		FunctionName: functionName,
		Args:         args,
		Mode:         mode,
	}
	mock.lockCall17.Lock()
	mock.calls.Call17 = append(mock.calls.Call17, callInfo)
	mock.lockCall17.Unlock()
	return mock.Call17Func(functionName, args, mode)
}

// Call17Calls gets all the calls that were made to Call17.
// Check the length with:
//
//	len(mockedPooler.Call17Calls())
func (mock *PoolerMock) Call17Calls() []struct {
	FunctionName string
	Args         interface{}
	Mode         pool.Mode
} {
	var calls []struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}
	mock.lockCall17.RLock()
	calls = mock.calls.Call17
	mock.lockCall17.RUnlock()
	return calls
}

// Call17Async calls Call17AsyncFunc.
func (mock *PoolerMock) Call17Async(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
	if mock.Call17AsyncFunc == nil {
		panic("PoolerMock.Call17AsyncFunc: method is nil but Pooler.Call17Async was just called")
	}
	callInfo := struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}{
		FunctionName: functionName,
		Args:         args,
		Mode:         mode,
	}
	mock.lockCall17Async.Lock()
	mock.calls.Call17Async = append(mock.calls.Call17Async, callInfo)
	mock.lockCall17Async.Unlock()
	return mock.Call17AsyncFunc(functionName, args, mode)
}

// Call17AsyncCalls gets all the calls that were made to Call17Async.
// Check the length with:
//
//	len(mockedPooler.Call17AsyncCalls())
func (mock *PoolerMock) Call17AsyncCalls() []struct {
	FunctionName string
	Args         interface{}
	Mode         pool.Mode
} {
	var calls []struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}
	mock.lockCall17Async.RLock()
	calls = mock.calls.Call17Async
	mock.lockCall17Async.RUnlock()
	return calls
}

// Call17Typed calls Call17TypedFunc.
func (mock *PoolerMock) Call17Typed(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
	if mock.Call17TypedFunc == nil {
		panic("PoolerMock.Call17TypedFunc: method is nil but Pooler.Call17Typed was just called")
	}
	callInfo := struct {
		FunctionName string
		Args         interface{}
		Result       interface{}
		Mode         pool.Mode
	}{
		FunctionName: functionName,
		Args:         args,
		Result:       result,
		Mode:         mode,
	}
	mock.lockCall17Typed.Lock()
	mock.calls.Call17Typed = append(mock.calls.Call17Typed, callInfo)
	mock.lockCall17Typed.Unlock()
	return mock.Call17TypedFunc(functionName, args, result, mode)
}

// Call17TypedCalls gets all the calls that were made to Call17Typed.
// Check the length with:
//
//	len(mockedPooler.Call17TypedCalls())
func (mock *PoolerMock) Call17TypedCalls() []struct {
	FunctionName string
	Args         interface{}
	Result       interface{}
	Mode         pool.Mode
} {
	var calls []struct {
		FunctionName string
		Args         interface{}
		Result       interface{}
		Mode         pool.Mode
	}
	mock.lockCall17Typed.RLock()
	calls = mock.calls.Call17Typed
	mock.lockCall17Typed.RUnlock()
	return calls
}

// CallAsync calls CallAsyncFunc.
func (mock *PoolerMock) CallAsync(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
	if mock.CallAsyncFunc == nil {
		panic("PoolerMock.CallAsyncFunc: method is nil but Pooler.CallAsync was just called")
	}
	callInfo := struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}{
		FunctionName: functionName,
		Args:         args,
		Mode:         mode,
	}
	mock.lockCallAsync.Lock()
	mock.calls.CallAsync = append(mock.calls.CallAsync, callInfo)
	mock.lockCallAsync.Unlock()
	return mock.CallAsyncFunc(functionName, args, mode)
}

// CallAsyncCalls gets all the calls that were made to CallAsync.
// Check the length with:
//
//	len(mockedPooler.CallAsyncCalls())
func (mock *PoolerMock) CallAsyncCalls() []struct {
	FunctionName string
	Args         interface{}
	Mode         pool.Mode
} {
	var calls []struct {
		FunctionName string
		Args         interface{}
		Mode         pool.Mode
	}
	mock.lockCallAsync.RLock()
	calls = mock.calls.CallAsync
	mock.lockCallAsync.RUnlock()
	return calls
}

// CallTyped calls CallTypedFunc.
func (mock *PoolerMock) CallTyped(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
	if mock.CallTypedFunc == nil {
		panic("PoolerMock.CallTypedFunc: method is nil but Pooler.CallTyped was just called")
	}
	callInfo := struct {
		FunctionName string
		Args         interface{}
		Result       interface{}
		Mode         pool.Mode
	}{
		FunctionName: functionName,
		Args:         args,
		Result:       result,
		Mode:         mode,
	}
	mock.lockCallTyped.Lock()
	mock.calls.CallTyped = append(mock.calls.CallTyped, callInfo)
	mock.lockCallTyped.Unlock()
	return mock.CallTypedFunc(functionName, args, result, mode)
}

// CallTypedCalls gets all the calls that were made to CallTyped.
// Check the length with:
//
//	len(mockedPooler.CallTypedCalls())
func (mock *PoolerMock) CallTypedCalls() []struct {
	FunctionName string
	Args         interface{}
	Result       interface{}
	Mode         pool.Mode
} {
	var calls []struct {
		FunctionName string
		Args         interface{}
		Result       interface{}
		Mode         pool.Mode
	}
	mock.lockCallTyped.RLock()
	calls = mock.calls.CallTyped
	mock.lockCallTyped.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *PoolerMock) Close() []error {
	if mock.CloseFunc == nil {
		panic("PoolerMock.CloseFunc: method is nil but Pooler.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedPooler.CloseCalls())
func (mock *PoolerMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// ConfiguredTimeout calls ConfiguredTimeoutFunc.
func (mock *PoolerMock) ConfiguredTimeout(mode pool.Mode) (time.Duration, error) {
	if mock.ConfiguredTimeoutFunc == nil {
		panic("PoolerMock.ConfiguredTimeoutFunc: method is nil but Pooler.ConfiguredTimeout was just called")
	}
	callInfo := struct {
		Mode pool.Mode
	}{
		Mode: mode,
	}
	mock.lockConfiguredTimeout.Lock()
	mock.calls.ConfiguredTimeout = append(mock.calls.ConfiguredTimeout, callInfo)
	mock.lockConfiguredTimeout.Unlock()
	return mock.ConfiguredTimeoutFunc(mode)
}

// ConfiguredTimeoutCalls gets all the calls that were made to ConfiguredTimeout.
// Check the length with:
//
//	len(mockedPooler.ConfiguredTimeoutCalls())
func (mock *PoolerMock) ConfiguredTimeoutCalls() []struct {
	Mode pool.Mode
} {
	var calls []struct {
		Mode pool.Mode
	}
	mock.lockConfiguredTimeout.RLock()
	calls = mock.calls.ConfiguredTimeout
	mock.lockConfiguredTimeout.RUnlock()
	return calls
}

// ConnectedNow calls ConnectedNowFunc.
func (mock *PoolerMock) ConnectedNow(mode pool.Mode) (bool, error) {
	if mock.ConnectedNowFunc == nil {
		panic("PoolerMock.ConnectedNowFunc: method is nil but Pooler.ConnectedNow was just called")
	}
	callInfo := struct {
		Mode pool.Mode
	}{
		Mode: mode,
	}
	mock.lockConnectedNow.Lock()
	mock.calls.ConnectedNow = append(mock.calls.ConnectedNow, callInfo)
	mock.lockConnectedNow.Unlock()
	return mock.ConnectedNowFunc(mode)
}

// ConnectedNowCalls gets all the calls that were made to ConnectedNow.
// Check the length with:
//
//	len(mockedPooler.ConnectedNowCalls())
func (mock *PoolerMock) ConnectedNowCalls() []struct {
	Mode pool.Mode
} {
	var calls []struct {
		Mode pool.Mode
	}
	mock.lockConnectedNow.RLock()
	calls = mock.calls.ConnectedNow
	mock.lockConnectedNow.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *PoolerMock) Delete(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) ([]interface{}, error) {
	if mock.DeleteFunc == nil {
		panic("PoolerMock.DeleteFunc: method is nil but Pooler.Delete was just called")
	}
	callInfo := struct {
		Space interface{}
		Index interface{}
		Key   interface{}
		Mode  []pool.Mode
	}{
		Space: space,
		Index: index,
		Key:   key,
		Mode:  mode,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(space, index, key, mode...)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedPooler.DeleteCalls())
func (mock *PoolerMock) DeleteCalls() []struct {
	Space interface{}
	Index interface{}
	Key   interface{}
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Index interface{}
		Key   interface{}
		Mode  []pool.Mode
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeleteAsync calls DeleteAsyncFunc.
func (mock *PoolerMock) DeleteAsync(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) *tarantool.Future {
	if mock.DeleteAsyncFunc == nil {
		panic("PoolerMock.DeleteAsyncFunc: method is nil but Pooler.DeleteAsync was just called")
	}
	callInfo := struct {
		Space interface{}
		Index interface{}
		Key   interface{}
		Mode  []pool.Mode
	}{
		Space: space,
		Index: index,
		Key:   key,
		Mode:  mode,
	}
	mock.lockDeleteAsync.Lock()
	mock.calls.DeleteAsync = append(mock.calls.DeleteAsync, callInfo)
	mock.lockDeleteAsync.Unlock()
	return mock.DeleteAsyncFunc(space, index, key, mode...)
}

// DeleteAsyncCalls gets all the calls that were made to DeleteAsync.
// Check the length with:
//
//	len(mockedPooler.DeleteAsyncCalls())
func (mock *PoolerMock) DeleteAsyncCalls() []struct {
	Space interface{}
	Index interface{}
	Key   interface{}
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Index interface{}
		Key   interface{}
		Mode  []pool.Mode
	}
	mock.lockDeleteAsync.RLock()
	calls = mock.calls.DeleteAsync
	mock.lockDeleteAsync.RUnlock()
	return calls
}

// DeleteTyped calls DeleteTypedFunc.
func (mock *PoolerMock) DeleteTyped(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error {
	if mock.DeleteTypedFunc == nil {
		panic("PoolerMock.DeleteTypedFunc: method is nil but Pooler.DeleteTyped was just called")
	}
	callInfo := struct {
		Space  interface{}
		Index  interface{}
		Key    interface{}
		Result interface{}
		Mode   []pool.Mode
	}{
		Space:  space,
		Index:  index,
		Key:    key,
		Result: result,
		Mode:   mode,
	}
	mock.lockDeleteTyped.Lock()
	mock.calls.DeleteTyped = append(mock.calls.DeleteTyped, callInfo)
	mock.lockDeleteTyped.Unlock()
	return mock.DeleteTypedFunc(space, index, key, result, mode...)
}

// DeleteTypedCalls gets all the calls that were made to DeleteTyped.
// Check the length with:
//
//	len(mockedPooler.DeleteTypedCalls())
func (mock *PoolerMock) DeleteTypedCalls() []struct {
	Space  interface{}
	Index  interface{}
	Key    interface{}
	Result interface{}
	Mode   []pool.Mode
} {
	var calls []struct {
		Space  interface{}
		Index  interface{}
		Key    interface{}
		Result interface{}
		Mode   []pool.Mode
	}
	mock.lockDeleteTyped.RLock()
	calls = mock.calls.DeleteTyped
	mock.lockDeleteTyped.RUnlock()
	return calls
}

// Do calls DoFunc.
func (mock *PoolerMock) Do(req tarantool.Request, mode pool.Mode) *tarantool.Future {
	if mock.DoFunc == nil {
		panic("PoolerMock.DoFunc: method is nil but Pooler.Do was just called")
	}
	callInfo := struct {
		Req  tarantool.Request
		Mode pool.Mode
	}{
		Req:  req,
		Mode: mode,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(req, mode)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//
//	len(mockedPooler.DoCalls())
func (mock *PoolerMock) DoCalls() []struct {
	Req  tarantool.Request
	Mode pool.Mode
} {
	var calls []struct {
		Req  tarantool.Request
		Mode pool.Mode
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// Eval calls EvalFunc.
func (mock *PoolerMock) Eval(expr string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	if mock.EvalFunc == nil {
		panic("PoolerMock.EvalFunc: method is nil but Pooler.Eval was just called")
	}
	callInfo := struct {
		Expr string
		Args interface{}
		Mode pool.Mode
	}{
		Expr: expr,
		Args: args,
		Mode: mode,
	}
	mock.lockEval.Lock()
	mock.calls.Eval = append(mock.calls.Eval, callInfo)
	mock.lockEval.Unlock()
	return mock.EvalFunc(expr, args, mode)
}

// EvalCalls gets all the calls that were made to Eval.
// Check the length with:
//
//	len(mockedPooler.EvalCalls())
func (mock *PoolerMock) EvalCalls() []struct {
	Expr string
	Args interface{}
	Mode pool.Mode
} {
	var calls []struct {
		Expr string
		Args interface{}
		Mode pool.Mode
	}
	mock.lockEval.RLock()
	calls = mock.calls.Eval
	mock.lockEval.RUnlock()
	return calls
}

// EvalAsync calls EvalAsyncFunc.
func (mock *PoolerMock) EvalAsync(expr string, args interface{}, mode pool.Mode) *tarantool.Future {
	if mock.EvalAsyncFunc == nil {
		panic("PoolerMock.EvalAsyncFunc: method is nil but Pooler.EvalAsync was just called")
	}
	callInfo := struct {
		Expr string
		Args interface{}
		Mode pool.Mode
	}{
		Expr: expr,
		Args: args,
		Mode: mode,
	}
	mock.lockEvalAsync.Lock()
	mock.calls.EvalAsync = append(mock.calls.EvalAsync, callInfo)
	mock.lockEvalAsync.Unlock()
	return mock.EvalAsyncFunc(expr, args, mode)
}

// EvalAsyncCalls gets all the calls that were made to EvalAsync.
// Check the length with:
//
//	len(mockedPooler.EvalAsyncCalls())
func (mock *PoolerMock) EvalAsyncCalls() []struct {
	Expr string
	Args interface{}
	Mode pool.Mode
} {
	var calls []struct {
		Expr string
		Args interface{}
		Mode pool.Mode
	}
	mock.lockEvalAsync.RLock()
	calls = mock.calls.EvalAsync
	mock.lockEvalAsync.RUnlock()
	return calls
}

// EvalTyped calls EvalTypedFunc.
func (mock *PoolerMock) EvalTyped(expr string, args interface{}, result interface{}, mode pool.Mode) error {
	if mock.EvalTypedFunc == nil {
		panic("PoolerMock.EvalTypedFunc: method is nil but Pooler.EvalTyped was just called")
	}
	callInfo := struct {
		Expr   string
		Args   interface{}
		Result interface{}
		Mode   pool.Mode
	}{
		Expr:   expr,
		Args:   args,
		Result: result,
		Mode:   mode,
	}
	mock.lockEvalTyped.Lock()
	mock.calls.EvalTyped = append(mock.calls.EvalTyped, callInfo)
	mock.lockEvalTyped.Unlock()
	return mock.EvalTypedFunc(expr, args, result, mode)
}

// EvalTypedCalls gets all the calls that were made to EvalTyped.
// Check the length with:
//
//	len(mockedPooler.EvalTypedCalls())
func (mock *PoolerMock) EvalTypedCalls() []struct {
	Expr   string
	Args   interface{}
	Result interface{}
	Mode   pool.Mode
} {
	var calls []struct {
		Expr   string
		Args   interface{}
		Result interface{}
		Mode   pool.Mode
	}
	mock.lockEvalTyped.RLock()
	calls = mock.calls.EvalTyped
	mock.lockEvalTyped.RUnlock()
	return calls
}

// Execute calls ExecuteFunc.
func (mock *PoolerMock) Execute(expr string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	if mock.ExecuteFunc == nil {
		panic("PoolerMock.ExecuteFunc: method is nil but Pooler.Execute was just called")
	}
	callInfo := struct {
		Expr string
		Args interface{}
		Mode pool.Mode
	}{
		Expr: expr,
		Args: args,
		Mode: mode,
	}
	mock.lockExecute.Lock()
	mock.calls.Execute = append(mock.calls.Execute, callInfo)
	mock.lockExecute.Unlock()
	return mock.ExecuteFunc(expr, args, mode)
}

// ExecuteCalls gets all the calls that were made to Execute.
// Check the length with:
//
//	len(mockedPooler.ExecuteCalls())
func (mock *PoolerMock) ExecuteCalls() []struct {
	Expr string
	Args interface{}
	Mode pool.Mode
} {
	var calls []struct {
		Expr string
		Args interface{}
		Mode pool.Mode
	}
	mock.lockExecute.RLock()
	calls = mock.calls.Execute
	mock.lockExecute.RUnlock()
	return calls
}

// ExecuteAsync calls ExecuteAsyncFunc.
func (mock *PoolerMock) ExecuteAsync(expr string, args interface{}, mode pool.Mode) *tarantool.Future {
	if mock.ExecuteAsyncFunc == nil {
		panic("PoolerMock.ExecuteAsyncFunc: method is nil but Pooler.ExecuteAsync was just called")
	}
	callInfo := struct {
		Expr string
		Args interface{}
		Mode pool.Mode
	}{
		Expr: expr,
		Args: args,
		Mode: mode,
	}
	mock.lockExecuteAsync.Lock()
	mock.calls.ExecuteAsync = append(mock.calls.ExecuteAsync, callInfo)
	mock.lockExecuteAsync.Unlock()
	return mock.ExecuteAsyncFunc(expr, args, mode)
}

// ExecuteAsyncCalls gets all the calls that were made to ExecuteAsync.
// Check the length with:
//
//	len(mockedPooler.ExecuteAsyncCalls())
func (mock *PoolerMock) ExecuteAsyncCalls() []struct {
	Expr string
	Args interface{}
	Mode pool.Mode
} {
	var calls []struct {
		Expr string
		Args interface{}
		Mode pool.Mode
	}
	mock.lockExecuteAsync.RLock()
	calls = mock.calls.ExecuteAsync
	mock.lockExecuteAsync.RUnlock()
	return calls
}

// ExecuteTyped calls ExecuteTypedFunc.
func (mock *PoolerMock) ExecuteTyped(expr string, args interface{}, result interface{}, mode pool.Mode) (tarantool.SQLInfo, []tarantool.ColumnMetaData, error) {
	if mock.ExecuteTypedFunc == nil {
		panic("PoolerMock.ExecuteTypedFunc: method is nil but Pooler.ExecuteTyped was just called")
	}
	callInfo := struct {
		Expr   string
		Args   interface{}
		Result interface{}
		Mode   pool.Mode
	}{
		Expr:   expr,
		Args:   args,
		Result: result,
		Mode:   mode,
	}
	mock.lockExecuteTyped.Lock()
	mock.calls.ExecuteTyped = append(mock.calls.ExecuteTyped, callInfo)
	mock.lockExecuteTyped.Unlock()
	return mock.ExecuteTypedFunc(expr, args, result, mode)
}

// ExecuteTypedCalls gets all the calls that were made to ExecuteTyped.
// Check the length with:
//
//	len(mockedPooler.ExecuteTypedCalls())
func (mock *PoolerMock) ExecuteTypedCalls() []struct {
	Expr   string
	Args   interface{}
	Result interface{}
	Mode   pool.Mode
} {
	var calls []struct {
		Expr   string
		Args   interface{}
		Result interface{}
		Mode   pool.Mode
	}
	mock.lockExecuteTyped.RLock()
	calls = mock.calls.ExecuteTyped
	mock.lockExecuteTyped.RUnlock()
	return calls
}

// GetTyped calls GetTypedFunc.
func (mock *PoolerMock) GetTyped(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error {
	if mock.GetTypedFunc == nil {
		panic("PoolerMock.GetTypedFunc: method is nil but Pooler.GetTyped was just called")
	}
	callInfo := struct {
		Space  interface{}
		Index  interface{}
		Key    interface{}
		Result interface{}
		Mode   []pool.Mode
	}{
		Space:  space,
		Index:  index,
		Key:    key,
		Result: result,
		Mode:   mode,
	}
	mock.lockGetTyped.Lock()
	mock.calls.GetTyped = append(mock.calls.GetTyped, callInfo)
	mock.lockGetTyped.Unlock()
	return mock.GetTypedFunc(space, index, key, result, mode...)
}

// GetTypedCalls gets all the calls that were made to GetTyped.
// Check the length with:
//
//	len(mockedPooler.GetTypedCalls())
func (mock *PoolerMock) GetTypedCalls() []struct {
	Space  interface{}
	Index  interface{}
	Key    interface{}
	Result interface{}
	Mode   []pool.Mode
} {
	var calls []struct {
		Space  interface{}
		Index  interface{}
		Key    interface{}
		Result interface{}
		Mode   []pool.Mode
	}
	mock.lockGetTyped.RLock()
	calls = mock.calls.GetTyped
	mock.lockGetTyped.RUnlock()
	return calls
}

// Insert calls InsertFunc.
func (mock *PoolerMock) Insert(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error) {
	if mock.InsertFunc == nil {
		panic("PoolerMock.InsertFunc: method is nil but Pooler.Insert was just called")
	}
	callInfo := struct {
		Space interface{}
		Tuple interface{}
		Mode  []pool.Mode
	}{
		Space: space,
		Tuple: tuple,
		Mode:  mode,
	}
	mock.lockInsert.Lock()
	mock.calls.Insert = append(mock.calls.Insert, callInfo)
	mock.lockInsert.Unlock()
	return mock.InsertFunc(space, tuple, mode...)
}

// InsertCalls gets all the calls that were made to Insert.
// Check the length with:
//
//	len(mockedPooler.InsertCalls())
func (mock *PoolerMock) InsertCalls() []struct {
	Space interface{}
	Tuple interface{}
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Tuple interface{}
		Mode  []pool.Mode
	}
	mock.lockInsert.RLock()
	calls = mock.calls.Insert
	mock.lockInsert.RUnlock()
	return calls
}

// InsertAsync calls InsertAsyncFunc.
func (mock *PoolerMock) InsertAsync(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future {
	if mock.InsertAsyncFunc == nil {
		panic("PoolerMock.InsertAsyncFunc: method is nil but Pooler.InsertAsync was just called")
	}
	callInfo := struct {
		Space interface{}
		Tuple interface{}
		Mode  []pool.Mode
	}{
		Space: space,
		Tuple: tuple,
		Mode:  mode,
	}
	mock.lockInsertAsync.Lock()
	mock.calls.InsertAsync = append(mock.calls.InsertAsync, callInfo)
	mock.lockInsertAsync.Unlock()
	return mock.InsertAsyncFunc(space, tuple, mode...)
}

// InsertAsyncCalls gets all the calls that were made to InsertAsync.
// Check the length with:
//
//	len(mockedPooler.InsertAsyncCalls())
func (mock *PoolerMock) InsertAsyncCalls() []struct {
	Space interface{}
	Tuple interface{}
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Tuple interface{}
		Mode  []pool.Mode
	}
	mock.lockInsertAsync.RLock()
	calls = mock.calls.InsertAsync
	mock.lockInsertAsync.RUnlock()
	return calls
}

// InsertTyped calls InsertTypedFunc.
func (mock *PoolerMock) InsertTyped(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error {
	if mock.InsertTypedFunc == nil {
		panic("PoolerMock.InsertTypedFunc: method is nil but Pooler.InsertTyped was just called")
	}
	callInfo := struct {
		Space  interface{}
		Tuple  interface{}
		Result interface{}
		Mode   []pool.Mode
	}{
		Space:  space,
		Tuple:  tuple,
		Result: result,
		Mode:   mode,
	}
	mock.lockInsertTyped.Lock()
	mock.calls.InsertTyped = append(mock.calls.InsertTyped, callInfo)
	mock.lockInsertTyped.Unlock()
	return mock.InsertTypedFunc(space, tuple, result, mode...)
}

// InsertTypedCalls gets all the calls that were made to InsertTyped.
// Check the length with:
//
//	len(mockedPooler.InsertTypedCalls())
func (mock *PoolerMock) InsertTypedCalls() []struct {
	Space  interface{}
	Tuple  interface{}
	Result interface{}
	Mode   []pool.Mode
} {
	var calls []struct {
		Space  interface{}
		Tuple  interface{}
		Result interface{}
		Mode   []pool.Mode
	}
	mock.lockInsertTyped.RLock()
	calls = mock.calls.InsertTyped
	mock.lockInsertTyped.RUnlock()
	return calls
}

// NewPrepared calls NewPreparedFunc.
func (mock *PoolerMock) NewPrepared(expr string, mode pool.Mode) (*tarantool.Prepared, error) {
	if mock.NewPreparedFunc == nil {
		panic("PoolerMock.NewPreparedFunc: method is nil but Pooler.NewPrepared was just called")
	}
	callInfo := struct {
		Expr string
		Mode pool.Mode
	}{
		Expr: expr,
		Mode: mode,
	}
	mock.lockNewPrepared.Lock()
	mock.calls.NewPrepared = append(mock.calls.NewPrepared, callInfo)
	mock.lockNewPrepared.Unlock()
	return mock.NewPreparedFunc(expr, mode)
}

// NewPreparedCalls gets all the calls that were made to NewPrepared.
// Check the length with:
//
//	len(mockedPooler.NewPreparedCalls())
func (mock *PoolerMock) NewPreparedCalls() []struct {
	Expr string
	Mode pool.Mode
} {
	var calls []struct {
		Expr string
		Mode pool.Mode
	}
	mock.lockNewPrepared.RLock()
	calls = mock.calls.NewPrepared
	mock.lockNewPrepared.RUnlock()
	return calls
}

// NewStream calls NewStreamFunc.
func (mock *PoolerMock) NewStream(mode pool.Mode) (*tarantool.Stream, error) {
	if mock.NewStreamFunc == nil {
		panic("PoolerMock.NewStreamFunc: method is nil but Pooler.NewStream was just called")
	}
	callInfo := struct {
		Mode pool.Mode
	}{
		Mode: mode,
	}
	mock.lockNewStream.Lock()
	mock.calls.NewStream = append(mock.calls.NewStream, callInfo)
	mock.lockNewStream.Unlock()
	return mock.NewStreamFunc(mode)
}

// NewStreamCalls gets all the calls that were made to NewStream.
// Check the length with:
//
//	len(mockedPooler.NewStreamCalls())
func (mock *PoolerMock) NewStreamCalls() []struct {
	Mode pool.Mode
} {
	var calls []struct {
		Mode pool.Mode
	}
	mock.lockNewStream.RLock()
	calls = mock.calls.NewStream
	mock.lockNewStream.RUnlock()
	return calls
}

// NewWatcher calls NewWatcherFunc.
func (mock *PoolerMock) NewWatcher(key string, callback tarantool.WatchCallback, mode pool.Mode) (tarantool.Watcher, error) {
	if mock.NewWatcherFunc == nil {
		panic("PoolerMock.NewWatcherFunc: method is nil but Pooler.NewWatcher was just called")
	}
	callInfo := struct {
		Key      string
		Callback tarantool.WatchCallback
		Mode     pool.Mode
	}{
		Key:      key,
		Callback: callback,
		Mode:     mode,
	}
	mock.lockNewWatcher.Lock()
	mock.calls.NewWatcher = append(mock.calls.NewWatcher, callInfo)
	mock.lockNewWatcher.Unlock()
	return mock.NewWatcherFunc(key, callback, mode)
}

// NewWatcherCalls gets all the calls that were made to NewWatcher.
// Check the length with:
//
//	len(mockedPooler.NewWatcherCalls())
func (mock *PoolerMock) NewWatcherCalls() []struct {
	Key      string
	Callback tarantool.WatchCallback
	Mode     pool.Mode
} {
	var calls []struct {
		Key      string
		Callback tarantool.WatchCallback
		Mode     pool.Mode
	}
	mock.lockNewWatcher.RLock()
	calls = mock.calls.NewWatcher
	mock.lockNewWatcher.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *PoolerMock) Ping(mode pool.Mode) ([]interface{}, error) {
	if mock.PingFunc == nil {
		panic("PoolerMock.PingFunc: method is nil but Pooler.Ping was just called")
	}
	callInfo := struct {
		Mode pool.Mode
	}{
		Mode: mode,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(mode)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedPooler.PingCalls())
func (mock *PoolerMock) PingCalls() []struct {
	Mode pool.Mode
} {
	var calls []struct {
		Mode pool.Mode
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// Replace calls ReplaceFunc.
func (mock *PoolerMock) Replace(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error) {
	if mock.ReplaceFunc == nil {
		panic("PoolerMock.ReplaceFunc: method is nil but Pooler.Replace was just called")
	}
	callInfo := struct {
		Space interface{}
		Tuple interface{}
		Mode  []pool.Mode
	}{
		Space: space,
		Tuple: tuple,
		Mode:  mode,
	}
	mock.lockReplace.Lock()
	mock.calls.Replace = append(mock.calls.Replace, callInfo)
	mock.lockReplace.Unlock()
	return mock.ReplaceFunc(space, tuple, mode...)
}

// ReplaceCalls gets all the calls that were made to Replace.
// Check the length with:
//
//	len(mockedPooler.ReplaceCalls())
func (mock *PoolerMock) ReplaceCalls() []struct {
	Space interface{}
	Tuple interface{}
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Tuple interface{}
		Mode  []pool.Mode
	}
	mock.lockReplace.RLock()
	calls = mock.calls.Replace
	mock.lockReplace.RUnlock()
	return calls
}

// ReplaceAsync calls ReplaceAsyncFunc.
func (mock *PoolerMock) ReplaceAsync(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future {
	if mock.ReplaceAsyncFunc == nil {
		panic("PoolerMock.ReplaceAsyncFunc: method is nil but Pooler.ReplaceAsync was just called")
	}
	callInfo := struct {
		Space interface{}
		Tuple interface{}
		Mode  []pool.Mode
	}{
		Space: space,
		Tuple: tuple,
		Mode:  mode,
	}
	mock.lockReplaceAsync.Lock()
	mock.calls.ReplaceAsync = append(mock.calls.ReplaceAsync, callInfo)
	mock.lockReplaceAsync.Unlock()
	return mock.ReplaceAsyncFunc(space, tuple, mode...)
}

// ReplaceAsyncCalls gets all the calls that were made to ReplaceAsync.
// Check the length with:
//
//	len(mockedPooler.ReplaceAsyncCalls())
func (mock *PoolerMock) ReplaceAsyncCalls() []struct {
	Space interface{}
	Tuple interface{}
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Tuple interface{}
		Mode  []pool.Mode
	}
	mock.lockReplaceAsync.RLock()
	calls = mock.calls.ReplaceAsync
	mock.lockReplaceAsync.RUnlock()
	return calls
}

// ReplaceTyped calls ReplaceTypedFunc.
func (mock *PoolerMock) ReplaceTyped(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error {
	if mock.ReplaceTypedFunc == nil {
		panic("PoolerMock.ReplaceTypedFunc: method is nil but Pooler.ReplaceTyped was just called")
	}
	callInfo := struct {
		Space  interface{}
		Tuple  interface{}
		Result interface{}
		Mode   []pool.Mode
	}{
		Space:  space,
		Tuple:  tuple,
		Result: result,
		Mode:   mode,
	}
	mock.lockReplaceTyped.Lock()
	mock.calls.ReplaceTyped = append(mock.calls.ReplaceTyped, callInfo)
	mock.lockReplaceTyped.Unlock()
	return mock.ReplaceTypedFunc(space, tuple, result, mode...)
}

// ReplaceTypedCalls gets all the calls that were made to ReplaceTyped.
// Check the length with:
//
//	len(mockedPooler.ReplaceTypedCalls())
func (mock *PoolerMock) ReplaceTypedCalls() []struct {
	Space  interface{}
	Tuple  interface{}
	Result interface{}
	Mode   []pool.Mode
} {
	var calls []struct {
		Space  interface{}
		Tuple  interface{}
		Result interface{}
		Mode   []pool.Mode
	}
	mock.lockReplaceTyped.RLock()
	calls = mock.calls.ReplaceTyped
	mock.lockReplaceTyped.RUnlock()
	return calls
}

// Select calls SelectFunc.
func (mock *PoolerMock) Select(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) ([]interface{}, error) {
	if mock.SelectFunc == nil {
		panic("PoolerMock.SelectFunc: method is nil but Pooler.Select was just called")
	}
	callInfo := struct {
		Space    interface{}
		Index    interface{}
		Offset   uint32
		Limit    uint32
		Iterator tarantool.Iter
		Key      interface{}
		Mode     []pool.Mode
	}{
		Space:    space,
		Index:    index,
		Offset:   offset,
		Limit:    limit,
		Iterator: iterator,
		Key:      key,
		Mode:     mode,
	}
	mock.lockSelect.Lock()
	mock.calls.Select = append(mock.calls.Select, callInfo)
	mock.lockSelect.Unlock()
	return mock.SelectFunc(space, index, offset, limit, iterator, key, mode...)
}

// SelectCalls gets all the calls that were made to Select.
// Check the length with:
//
//	len(mockedPooler.SelectCalls())
func (mock *PoolerMock) SelectCalls() []struct {
	Space    interface{}
	Index    interface{}
	Offset   uint32
	Limit    uint32
	Iterator tarantool.Iter
	Key      interface{}
	Mode     []pool.Mode
} {
	var calls []struct {
		Space    interface{}
		Index    interface{}
		Offset   uint32
		Limit    uint32
		Iterator tarantool.Iter
		Key      interface{}
		Mode     []pool.Mode
	}
	mock.lockSelect.RLock()
	calls = mock.calls.Select
	mock.lockSelect.RUnlock()
	return calls
}

// SelectAsync calls SelectAsyncFunc.
func (mock *PoolerMock) SelectAsync(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) *tarantool.Future {
	if mock.SelectAsyncFunc == nil {
		panic("PoolerMock.SelectAsyncFunc: method is nil but Pooler.SelectAsync was just called")
	}
	callInfo := struct {
		Space    interface{}
		Index    interface{}
		Offset   uint32
		Limit    uint32
		Iterator tarantool.Iter
		Key      interface{}
		Mode     []pool.Mode
	}{
		Space:    space,
		Index:    index,
		Offset:   offset,
		Limit:    limit,
		Iterator: iterator,
		Key:      key,
		Mode:     mode,
	}
	mock.lockSelectAsync.Lock()
	mock.calls.SelectAsync = append(mock.calls.SelectAsync, callInfo)
	mock.lockSelectAsync.Unlock()
	return mock.SelectAsyncFunc(space, index, offset, limit, iterator, key, mode...)
}

// SelectAsyncCalls gets all the calls that were made to SelectAsync.
// Check the length with:
//
//	len(mockedPooler.SelectAsyncCalls())
func (mock *PoolerMock) SelectAsyncCalls() []struct {
	Space    interface{}
	Index    interface{}
	Offset   uint32
	Limit    uint32
	Iterator tarantool.Iter
	Key      interface{}
	Mode     []pool.Mode
} {
	var calls []struct {
		Space    interface{}
		Index    interface{}
		Offset   uint32
		Limit    uint32
		Iterator tarantool.Iter
		Key      interface{}
		Mode     []pool.Mode
	}
	mock.lockSelectAsync.RLock()
	calls = mock.calls.SelectAsync
	mock.lockSelectAsync.RUnlock()
	return calls
}

// SelectTyped calls SelectTypedFunc.
func (mock *PoolerMock) SelectTyped(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, result interface{}, mode ...pool.Mode) error {
	if mock.SelectTypedFunc == nil {
		panic("PoolerMock.SelectTypedFunc: method is nil but Pooler.SelectTyped was just called")
	}
	callInfo := struct {
		Space    interface{}
		Index    interface{}
		Offset   uint32
		Limit    uint32
		Iterator tarantool.Iter
		Key      interface{}
		Result   interface{}
		Mode     []pool.Mode
	}{
		Space:    space,
		Index:    index,
		Offset:   offset,
		Limit:    limit,
		Iterator: iterator,
		Key:      key,
		Result:   result,
		Mode:     mode,
	}
	mock.lockSelectTyped.Lock()
	mock.calls.SelectTyped = append(mock.calls.SelectTyped, callInfo)
	mock.lockSelectTyped.Unlock()
	return mock.SelectTypedFunc(space, index, offset, limit, iterator, key, result, mode...)
}

// SelectTypedCalls gets all the calls that were made to SelectTyped.
// Check the length with:
//
//	len(mockedPooler.SelectTypedCalls())
func (mock *PoolerMock) SelectTypedCalls() []struct {
	Space    interface{}
	Index    interface{}
	Offset   uint32
	Limit    uint32
	Iterator tarantool.Iter
	Key      interface{}
	Result   interface{}
	Mode     []pool.Mode
} {
	var calls []struct {
		Space    interface{}
		Index    interface{}
		Offset   uint32
		Limit    uint32
		Iterator tarantool.Iter
		Key      interface{}
		Result   interface{}
		Mode     []pool.Mode
	}
	mock.lockSelectTyped.RLock()
	calls = mock.calls.SelectTyped
	mock.lockSelectTyped.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *PoolerMock) Update(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error) {
	if mock.UpdateFunc == nil {
		panic("PoolerMock.UpdateFunc: method is nil but Pooler.Update was just called")
	}
	callInfo := struct {
		Space interface{}
		Index interface{}
		Key   interface{}
		Ops   *tarantool.Operations
		Mode  []pool.Mode
	}{
		Space: space,
		Index: index,
		Key:   key,
		Ops:   ops,
		Mode:  mode,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(space, index, key, ops, mode...)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedPooler.UpdateCalls())
func (mock *PoolerMock) UpdateCalls() []struct {
	Space interface{}
	Index interface{}
	Key   interface{}
	Ops   *tarantool.Operations
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Index interface{}
		Key   interface{}
		Ops   *tarantool.Operations
		Mode  []pool.Mode
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// UpdateAsync calls UpdateAsyncFunc.
func (mock *PoolerMock) UpdateAsync(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future {
	if mock.UpdateAsyncFunc == nil {
		panic("PoolerMock.UpdateAsyncFunc: method is nil but Pooler.UpdateAsync was just called")
	}
	callInfo := struct {
		Space interface{}
		Index interface{}
		Key   interface{}
		Ops   *tarantool.Operations
		Mode  []pool.Mode
	}{
		Space: space,
		Index: index,
		Key:   key,
		Ops:   ops,
		Mode:  mode,
	}
	mock.lockUpdateAsync.Lock()
	mock.calls.UpdateAsync = append(mock.calls.UpdateAsync, callInfo)
	mock.lockUpdateAsync.Unlock()
	return mock.UpdateAsyncFunc(space, index, key, ops, mode...)
}

// UpdateAsyncCalls gets all the calls that were made to UpdateAsync.
// Check the length with:
//
//	len(mockedPooler.UpdateAsyncCalls())
func (mock *PoolerMock) UpdateAsyncCalls() []struct {
	Space interface{}
	Index interface{}
	Key   interface{}
	Ops   *tarantool.Operations
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Index interface{}
		Key   interface{}
		Ops   *tarantool.Operations
		Mode  []pool.Mode
	}
	mock.lockUpdateAsync.RLock()
	calls = mock.calls.UpdateAsync
	mock.lockUpdateAsync.RUnlock()
	return calls
}

// UpdateTyped calls UpdateTypedFunc.
func (mock *PoolerMock) UpdateTyped(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, result interface{}, mode ...pool.Mode) error {
	if mock.UpdateTypedFunc == nil {
		panic("PoolerMock.UpdateTypedFunc: method is nil but Pooler.UpdateTyped was just called")
	}
	callInfo := struct {
		Space  interface{}
		Index  interface{}
		Key    interface{}
		Ops    *tarantool.Operations
		Result interface{}
		Mode   []pool.Mode
	}{
		Space:  space,
		Index:  index,
		Key:    key,
		Ops:    ops,
		Result: result,
		Mode:   mode,
	}
	mock.lockUpdateTyped.Lock()
	mock.calls.UpdateTyped = append(mock.calls.UpdateTyped, callInfo)
	mock.lockUpdateTyped.Unlock()
	return mock.UpdateTypedFunc(space, index, key, ops, result, mode...)
}

// UpdateTypedCalls gets all the calls that were made to UpdateTyped.
// Check the length with:
//
//	len(mockedPooler.UpdateTypedCalls())
func (mock *PoolerMock) UpdateTypedCalls() []struct {
	Space  interface{}
	Index  interface{}
	Key    interface{}
	Ops    *tarantool.Operations
	Result interface{}
	Mode   []pool.Mode
} {
	var calls []struct {
		Space  interface{}
		Index  interface{}
		Key    interface{}
		Ops    *tarantool.Operations
		Result interface{}
		Mode   []pool.Mode
	}
	mock.lockUpdateTyped.RLock()
	calls = mock.calls.UpdateTyped
	mock.lockUpdateTyped.RUnlock()
	return calls
}

// Upsert calls UpsertFunc.
func (mock *PoolerMock) Upsert(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error) {
	if mock.UpsertFunc == nil {
		panic("PoolerMock.UpsertFunc: method is nil but Pooler.Upsert was just called")
	}
	callInfo := struct {
		Space interface{}
		Tuple interface{}
		Ops   *tarantool.Operations
		Mode  []pool.Mode
	}{
		Space: space,
		Tuple: tuple,
		Ops:   ops,
		Mode:  mode,
	}
	mock.lockUpsert.Lock()
	mock.calls.Upsert = append(mock.calls.Upsert, callInfo)
	mock.lockUpsert.Unlock()
	return mock.UpsertFunc(space, tuple, ops, mode...)
}

// UpsertCalls gets all the calls that were made to Upsert.
// Check the length with:
//
//	len(mockedPooler.UpsertCalls())
func (mock *PoolerMock) UpsertCalls() []struct {
	Space interface{}
	Tuple interface{}
	Ops   *tarantool.Operations
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Tuple interface{}
		Ops   *tarantool.Operations
		Mode  []pool.Mode
	}
	mock.lockUpsert.RLock()
	calls = mock.calls.Upsert
	mock.lockUpsert.RUnlock()
	return calls
}

// UpsertAsync calls UpsertAsyncFunc.
func (mock *PoolerMock) UpsertAsync(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future {
	if mock.UpsertAsyncFunc == nil {
		panic("PoolerMock.UpsertAsyncFunc: method is nil but Pooler.UpsertAsync was just called")
	}
	callInfo := struct {
		Space interface{}
		Tuple interface{}
		Ops   *tarantool.Operations
		Mode  []pool.Mode
	}{
		Space: space,
		Tuple: tuple,
		Ops:   ops,
		Mode:  mode,
	}
	mock.lockUpsertAsync.Lock()
	mock.calls.UpsertAsync = append(mock.calls.UpsertAsync, callInfo)
	mock.lockUpsertAsync.Unlock()
	return mock.UpsertAsyncFunc(space, tuple, ops, mode...)
}

// UpsertAsyncCalls gets all the calls that were made to UpsertAsync.
// Check the length with:
//
//	len(mockedPooler.UpsertAsyncCalls())
func (mock *PoolerMock) UpsertAsyncCalls() []struct {
	Space interface{}
	Tuple interface{}
	Ops   *tarantool.Operations
	Mode  []pool.Mode
} {
	var calls []struct {
		Space interface{}
		Tuple interface{}
		Ops   *tarantool.Operations
		Mode  []pool.Mode
	}
	mock.lockUpsertAsync.RLock()
	calls = mock.calls.UpsertAsync
	mock.lockUpsertAsync.RUnlock()
	return calls
}
